<?php

// Generated by Haxe 3.3.0
class haxe_Unserializer {
	public function __construct($buf) {
		if(!php_Boot::$skip_constructor) {
		$this->buf = $buf;
		$this->length = strlen($buf);
		$this->pos = 0;
		$this->scache = new _hx_array(array());
		$this->cache = new _hx_array(array());
		$r = haxe_Unserializer::$DEFAULT_RESOLVER;
		if($r === null) {
			$r = new haxe__Unserializer_DefaultResolver();
			haxe_Unserializer::$DEFAULT_RESOLVER = $r;
		}
		$this->resolver = $r;
	}}
	public $buf;
	public $pos;
	public $length;
	public $cache;
	public $scache;
	public $resolver;
	public function readDigits() {
		$k = 0;
		$s = false;
		$fpos = $this->pos;
		while(true) {
			$p = $this->pos;
			$c = ord(substr($this->buf,$p,1));
			$tmp = ($c === 0);
			if($tmp) {
				break;
			}
			if($c === 45) {
				if($this->pos !== $fpos) {
					break;
				}
				$s = true;
				$this->pos++;
				continue;
			}
			$tmp1 = null;
			if($c >= 48) {
				$tmp1 = $c > 57;
			} else {
				$tmp1 = true;
			}
			if($tmp1) {
				break;
			}
			$tmp2 = $k * 10;
			$k = $tmp2 + ($c - 48);
			$this->pos++;
			unset($tmp2,$tmp1,$tmp,$p,$c);
		}
		if($s) {
			$k *= -1;
		}
		return $k;
	}
	public function readFloat() {
		$p1 = $this->pos;
		while(true) {
			$p = $this->pos;
			$c = ord(substr($this->buf,$p,1));
			$tmp = ($c === 0);
			if($tmp) {
				break;
			}
			$tmp1 = null;
			$tmp2 = null;
			$tmp3 = null;
			if($c >= 43) {
				$tmp3 = $c < 58;
			} else {
				$tmp3 = false;
			}
			if(!$tmp3) {
				$tmp2 = $c === 101;
			} else {
				$tmp2 = true;
			}
			if(!$tmp2) {
				$tmp1 = $c === 69;
			} else {
				$tmp1 = true;
			}
			if($tmp1) {
				$this->pos++;
			} else {
				break;
			}
			unset($tmp3,$tmp2,$tmp1,$tmp,$p,$c);
		}
		$tmp4 = $this->pos - $p1;
		$tmp5 = _hx_substr($this->buf, $p1, $tmp4);
		return Std::parseFloat($tmp5);
	}
	public function unserializeObject($o) {
		while(true) {
			if($this->pos >= $this->length) {
				throw new HException("Invalid object");
			}
			$p = $this->pos;
			$tmp = ord(substr($this->buf,$p,1));
			if($tmp === 103) {
				break;
			}
			$k = $this->unserialize();
			$tmp1 = !Std::is($k, _hx_qtype("String"));
			if($tmp1) {
				throw new HException("Invalid object key");
			}
			$v = $this->unserialize();
			$o->{$k} = $v;
			unset($v,$tmp1,$tmp,$p,$k);
		}
		$this->pos++;
	}
	public function unserializeEnum($edecl, $tag) {
		$p = $this->pos++;
		$tmp = ord(substr($this->buf,$p,1));
		if($tmp !== 58) {
			throw new HException("Invalid enum format");
		}
		$nargs = $this->readDigits();
		if($nargs === 0) {
			return Type::createEnum($edecl, $tag, null);
		}
		$args = new _hx_array(array());
		while(true) {
			$tmp1 = $nargs--;
			if(!($tmp1 > 0)) {
				break;
			}
			$tmp2 = $this->unserialize();
			$args->push($tmp2);
			unset($tmp2,$tmp1);
		}
		return Type::createEnum($edecl, $tag, $args);
	}
	public function unserialize() {
		{
			$p = $this->pos++;
			$_g = ord(substr($this->buf,$p,1));
			switch($_g) {
			case 65:{
				$name = $this->unserialize();
				$cl = $this->resolver->resolveClass($name);
				if($cl === null) {
					throw new HException("Class not found " . _hx_string_or_null($name));
				}
				return $cl;
			}break;
			case 66:{
				$name1 = $this->unserialize();
				$e = $this->resolver->resolveEnum($name1);
				if($e === null) {
					throw new HException("Enum not found " . _hx_string_or_null($name1));
				}
				return $e;
			}break;
			case 67:{
				$name2 = $this->unserialize();
				$cl1 = $this->resolver->resolveClass($name2);
				if($cl1 === null) {
					throw new HException("Class not found " . _hx_string_or_null($name2));
				}
				$o = Type::createEmptyInstance($cl1);
				$this->cache->push($o);
				$o->hxUnserialize($this);
				$p1 = $this->pos++;
				$tmp = ord(substr($this->buf,$p1,1));
				if($tmp !== 103) {
					throw new HException("Invalid custom data");
				}
				return $o;
			}break;
			case 77:{
				$h = new haxe_ds_ObjectMap();
				$this->cache->push($h);
				$buf = $this->buf;
				while(true) {
					$p2 = $this->pos;
					$tmp1 = ord(substr($this->buf,$p2,1));
					if(!($tmp1 !== 104)) {
						break;
					}
					$s = $this->unserialize();
					$tmp2 = $this->unserialize();
					$h->set($s, $tmp2);
					unset($tmp2,$tmp1,$s,$p2);
				}
				$this->pos++;
				return $h;
			}break;
			case 82:{
				$n = $this->readDigits();
				$tmp3 = null;
				if($n >= 0) {
					$tmp3 = $n >= $this->scache->length;
				} else {
					$tmp3 = true;
				}
				if($tmp3) {
					throw new HException("Invalid string reference");
				}
				return $this->scache[$n];
			}break;
			case 97:{
				$buf1 = $this->buf;
				$a = new _hx_array(array());
				$this->cache->push($a);
				while(true) {
					$p3 = $this->pos;
					$c = ord(substr($this->buf,$p3,1));
					if($c === 104) {
						$this->pos++;
						break;
					}
					if($c === 117) {
						$this->pos++;
						$n1 = $this->readDigits();
						$tmp4 = $a->length + $n1 - 1;
						$a[$tmp4] = null;
						unset($tmp4,$n1);
					} else {
						$tmp5 = $this->unserialize();
						$a->push($tmp5);
						unset($tmp5);
					}
					unset($p3,$c);
				}
				return $a;
			}break;
			case 98:{
				$h1 = new haxe_ds_StringMap();
				$this->cache->push($h1);
				$buf2 = $this->buf;
				while(true) {
					$p4 = $this->pos;
					$tmp6 = ord(substr($this->buf,$p4,1));
					if(!($tmp6 !== 104)) {
						break;
					}
					$s1 = $this->unserialize();
					$tmp7 = $this->unserialize();
					$h1->set($s1, $tmp7);
					unset($tmp7,$tmp6,$s1,$p4);
				}
				$this->pos++;
				return $h1;
			}break;
			case 99:{
				$name3 = $this->unserialize();
				$cl2 = $this->resolver->resolveClass($name3);
				if($cl2 === null) {
					throw new HException("Class not found " . _hx_string_or_null($name3));
				}
				$o1 = Type::createEmptyInstance($cl2);
				$this->cache->push($o1);
				$this->unserializeObject($o1);
				return $o1;
			}break;
			case 100:{
				return $this->readFloat();
			}break;
			case 102:{
				return false;
			}break;
			case 105:{
				return $this->readDigits();
			}break;
			case 106:{
				$name4 = $this->unserialize();
				$edecl = $this->resolver->resolveEnum($name4);
				if($edecl === null) {
					throw new HException("Enum not found " . _hx_string_or_null($name4));
				}
				$this->pos++;
				$index = $this->readDigits();
				$tmp8 = Type::getEnumConstructs($edecl);
				$tag = $tmp8[$index];
				if($tag === null) {
					throw new HException("Unknown enum index " . _hx_string_or_null($name4) . "@" . _hx_string_rec($index, ""));
				}
				$e1 = $this->unserializeEnum($edecl, $tag);
				$this->cache->push($e1);
				return $e1;
			}break;
			case 107:{
				return Math::$NaN;
			}break;
			case 108:{
				$l = new HList();
				$this->cache->push($l);
				$buf3 = $this->buf;
				while(true) {
					$p5 = $this->pos;
					$tmp9 = ord(substr($this->buf,$p5,1));
					if(!($tmp9 !== 104)) {
						break;
					}
					$tmp10 = $this->unserialize();
					$l->add($tmp10);
					unset($tmp9,$tmp10,$p5);
				}
				$this->pos++;
				return $l;
			}break;
			case 109:{
				return Math::$NEGATIVE_INFINITY;
			}break;
			case 110:{
				return null;
			}break;
			case 111:{
				$o2 = _hx_anonymous(array());
				$this->cache->push($o2);
				$this->unserializeObject($o2);
				return $o2;
			}break;
			case 112:{
				return Math::$POSITIVE_INFINITY;
			}break;
			case 113:{
				$h2 = new haxe_ds_IntMap();
				$this->cache->push($h2);
				$buf4 = $this->buf;
				$p6 = $this->pos++;
				$c1 = ord(substr($this->buf,$p6,1));
				while($c1 === 58) {
					$i = $this->readDigits();
					$tmp11 = $this->unserialize();
					$h2->set($i, $tmp11);
					$p7 = $this->pos++;
					$c1 = ord(substr($this->buf,$p7,1));
					unset($tmp11,$p7,$i);
				}
				if($c1 !== 104) {
					throw new HException("Invalid IntMap format");
				}
				return $h2;
			}break;
			case 114:{
				$n2 = $this->readDigits();
				$tmp12 = null;
				if($n2 >= 0) {
					$tmp12 = $n2 >= $this->cache->length;
				} else {
					$tmp12 = true;
				}
				if($tmp12) {
					throw new HException("Invalid reference");
				}
				return $this->cache[$n2];
			}break;
			case 115:{
				$len = $this->readDigits();
				$buf5 = $this->buf;
				$tmp13 = null;
				$p8 = $this->pos++;
				$tmp14 = ord(substr($this->buf,$p8,1));
				if($tmp14 === 58) {
					$tmp13 = $this->length - $this->pos < $len;
				} else {
					$tmp13 = true;
				}
				if($tmp13) {
					throw new HException("Invalid bytes length");
				}
				$codes = haxe_Unserializer::$CODES;
				if($codes === null) {
					$codes = haxe_Unserializer::initCodes();
					haxe_Unserializer::$CODES = $codes;
				}
				$i1 = $this->pos;
				$rest = $len & 3;
				$tmp15 = ($len >> 2) * 3;
				$tmp16 = null;
				if($rest >= 2) {
					$tmp16 = $rest - 1;
				} else {
					$tmp16 = 0;
				}
				$size = $tmp15 + $tmp16;
				$max = $i1 + ($len - $rest);
				$bytes = haxe_io_Bytes::alloc($size);
				$bpos = 0;
				while($i1 < $max) {
					$index1 = $i1++;
					$tmp17 = ord(substr($buf5,$index1,1));
					$c11 = $codes[$tmp17];
					$index2 = $i1++;
					$tmp18 = ord(substr($buf5,$index2,1));
					$c2 = $codes[$tmp18];
					{
						$pos = $bpos++;
						$bytes->b->s[$pos] = chr($c11 << 2 | $c2 >> 4);
						unset($pos);
					}
					$index3 = $i1++;
					$tmp19 = ord(substr($buf5,$index3,1));
					$c3 = $codes[$tmp19];
					{
						$pos1 = $bpos++;
						$bytes->b->s[$pos1] = chr($c2 << 4 | $c3 >> 2);
						unset($pos1);
					}
					$index4 = $i1++;
					$tmp20 = ord(substr($buf5,$index4,1));
					$c4 = $codes[$tmp20];
					{
						$pos2 = $bpos++;
						$bytes->b->s[$pos2] = chr($c3 << 6 | $c4);
						unset($pos2);
					}
					unset($tmp20,$tmp19,$tmp18,$tmp17,$index4,$index3,$index2,$index1,$c4,$c3,$c2,$c11);
				}
				if($rest >= 2) {
					$index5 = $i1++;
					$tmp21 = ord(substr($buf5,$index5,1));
					$c12 = $codes[$tmp21];
					$index6 = $i1++;
					$tmp22 = ord(substr($buf5,$index6,1));
					$c21 = $codes[$tmp22];
					{
						$pos3 = $bpos++;
						$bytes->b->s[$pos3] = chr($c12 << 2 | $c21 >> 4);
					}
					if($rest === 3) {
						$index7 = $i1++;
						$tmp23 = ord(substr($buf5,$index7,1));
						$c31 = $codes[$tmp23];
						{
							$pos4 = $bpos++;
							$bytes->b->s[$pos4] = chr($c21 << 4 | $c31 >> 2);
						}
					}
				}
				$this->pos += $len;
				$this->cache->push($bytes);
				return $bytes;
			}break;
			case 116:{
				return true;
			}break;
			case 118:{
				$d = null;
				$tmp24 = null;
				$tmp25 = null;
				$tmp26 = null;
				$tmp27 = null;
				$tmp28 = null;
				$tmp29 = null;
				$tmp30 = null;
				$tmp31 = null;
				$p9 = $this->pos;
				$tmp32 = ord(substr($this->buf,$p9,1));
				if($tmp32 >= 48) {
					$p10 = $this->pos;
					$tmp33 = ord(substr($this->buf,$p10,1));
					$tmp31 = $tmp33 <= 57;
				} else {
					$tmp31 = false;
				}
				if($tmp31) {
					$p11 = $this->pos + 1;
					$tmp34 = ord(substr($this->buf,$p11,1));
					$tmp30 = $tmp34 >= 48;
				} else {
					$tmp30 = false;
				}
				if($tmp30) {
					$p12 = $this->pos + 1;
					$tmp35 = ord(substr($this->buf,$p12,1));
					$tmp29 = $tmp35 <= 57;
				} else {
					$tmp29 = false;
				}
				if($tmp29) {
					$p13 = $this->pos + 2;
					$tmp36 = ord(substr($this->buf,$p13,1));
					$tmp28 = $tmp36 >= 48;
				} else {
					$tmp28 = false;
				}
				if($tmp28) {
					$p14 = $this->pos + 2;
					$tmp37 = ord(substr($this->buf,$p14,1));
					$tmp27 = $tmp37 <= 57;
				} else {
					$tmp27 = false;
				}
				if($tmp27) {
					$p15 = $this->pos + 3;
					$tmp38 = ord(substr($this->buf,$p15,1));
					$tmp26 = $tmp38 >= 48;
				} else {
					$tmp26 = false;
				}
				if($tmp26) {
					$p16 = $this->pos + 3;
					$tmp39 = ord(substr($this->buf,$p16,1));
					$tmp25 = $tmp39 <= 57;
				} else {
					$tmp25 = false;
				}
				if($tmp25) {
					$p17 = $this->pos + 4;
					$tmp40 = ord(substr($this->buf,$p17,1));
					$tmp24 = $tmp40 === 45;
				} else {
					$tmp24 = false;
				}
				if($tmp24) {
					$tmp41 = _hx_substr($this->buf, $this->pos, 19);
					$d = Date::fromString($tmp41);
					$this->pos += 19;
				} else {
					$tmp42 = $this->readFloat();
					$d = Date::fromTime($tmp42);
				}
				$this->cache->push($d);
				return $d;
			}break;
			case 119:{
				$name5 = $this->unserialize();
				$edecl1 = $this->resolver->resolveEnum($name5);
				if($edecl1 === null) {
					throw new HException("Enum not found " . _hx_string_or_null($name5));
				}
				$tmp43 = $this->unserialize();
				$e2 = $this->unserializeEnum($edecl1, $tmp43);
				$this->cache->push($e2);
				return $e2;
			}break;
			case 120:{
				throw new HException($this->unserialize());
			}break;
			case 121:{
				$len1 = $this->readDigits();
				$tmp44 = null;
				$p18 = $this->pos++;
				$tmp45 = ord(substr($this->buf,$p18,1));
				if($tmp45 === 58) {
					$tmp44 = $this->length - $this->pos < $len1;
				} else {
					$tmp44 = true;
				}
				if($tmp44) {
					throw new HException("Invalid string length");
				}
				$s2 = _hx_substr($this->buf, $this->pos, $len1);
				$this->pos += $len1;
				$s2 = urldecode($s2);
				$this->scache->push($s2);
				return $s2;
			}break;
			case 122:{
				return 0;
			}break;
			default:{}break;
			}
		}
		$this->pos--;
		$tmp46 = _hx_char_at($this->buf, $this->pos);
		throw new HException("Invalid char " . _hx_string_or_null($tmp46) . " at position " . _hx_string_rec($this->pos, ""));
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	static $DEFAULT_RESOLVER;
	static $BASE64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:";
	static $CODES = null;
	static function initCodes() {
		$codes = new _hx_array(array());
		{
			$_g1 = 0;
			$_g = strlen(haxe_Unserializer::$BASE64);
			while($_g1 < $_g) {
				$i = $_g1++;
				$tmp = ord(substr(haxe_Unserializer::$BASE64,$i,1));
				$codes[$tmp] = $i;
				unset($tmp,$i);
			}
		}
		return $codes;
	}
	static function run($v) {
		return _hx_deref(new haxe_Unserializer($v))->unserialize();
	}
	function __toString() { return 'haxe.Unserializer'; }
}
haxe_Unserializer::$DEFAULT_RESOLVER = new haxe__Unserializer_DefaultResolver();
