<?php

// Generated by Haxe 3.3.0
class haxe_web_Dispatch {
	public function __construct($url, $params) {
		if(!php_Boot::$skip_constructor) {
		$this->parts = _hx_explode("/", $url);
		$tmp = $this->parts[0] === "";
		if($tmp) {
			$this->parts->shift();
		}
		$this->params = $params;
	}}
	public $parts;
	public $params;
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	static $GET_RULES;
	static function extractConfig($obj) {
		$c = Type::getClass($obj);
		$dc = haxe_rtti_Meta::getType($c);
		$m = $dc->dispatchConfig[0];
		$tmp = Std::is($m, _hx_qtype("String"));
		if($tmp) {
			$m = haxe_Unserializer::run($m);
			$dc->dispatchConfig[0] = $m;
		}
		return _hx_anonymous(array("obj" => $obj, "rules" => $m));
	}
	function __toString() { return 'haxe.web.Dispatch'; }
}
